\documentclass{article}
\usepackage[spanish]{babel}
\usepackage[a4paper,
            top=2cm,
            bottom=2cm,
            left=3cm,
            right=3cm,
            headheight=36pt,
            nomarginpar,
            includehead,
            includefoot,
            ]{geometry}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage[many, minted, listings]{tcolorbox}


% Opciones para entornos de código fuente
\definecolor{bg}{RGB}{29, 35, 49}
\definecolor{framecolor}{RGB}{125, 138, 151}

\newtcbinputlisting{\inputcode}[3][]{
    listing only,
    listing engine=minted,
    listing file={#3},
    minted language={#2},
    minted style=lightbulb,
    breakable,
    colback=bg,
    colframe=framecolor,
    #1
}


% Opciones para entornos de pseudocódigo
\lstset{
    breakatwhitespace=true,             % sets if automatic breaks should only happen at whitespace
    breaklines=true,                    % sets automatic line breaking
    keepspaces=true,                    % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    columns=flexible,
    escapechar=|,
    literate=   {á}{{\'a}}1             % corrige errores de utf-8
                {é}{{\'e}}1
                {í}{{\'i}}1
                {ó}{{\'o}}1
                {ú}{{\'u}}1,
}


% Encabezado y pie de página
\fancyhf{}
\lhead{\includegraphics[height=32pt]{img/logo-uncuyo-fing.pdf}}
\rhead{ Licenciatura en Ciencias de la Computación \\
        Algoritmos y Estructuras de Datos II \\
        TP N\textsuperscript{o} 5: Grafos}
\rfoot{\thepage}
\pagestyle{fancy}


\begin{document}
\input{titulo.tex}


\section*{Parte 1}
A partir de la siguiente definición:
\begin{lstlisting}
    Graph = Array(n, LinkedList())
\end{lstlisting}
Donde Graph es una representación de un grafo simple mediante listas de adyacencia resolver los siguiente ejercicios.


\subsection*{Ejercicio 1}
Implementar la función crear grafo que dada una lista de vértices y una lista de aristas cree un grafo con la representación por Lista de Adyacencia.
\begin{lstlisting}
|\textbf{def createGraph(List, List)}|
|\qquad \textbf{Descripción}|: Implementa la operación crear grafo.
|\qquad \textbf{Entrada}|: LinkedList con la lista de vértices y la LinkedList con la lista de aristas donde por cada par de elementos representa una conexión entre dos vértices.
|\qquad \textbf{Salida}|: Retorna el nuevo grafo.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 2}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def existPath(Grafo, v1, v2)}|
|\qquad \textbf{Descripción}|: Implementa la operación existe camino que busca si existe un camino entre los vértices v1 y v2.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia, v1 y v2 vértices en el grafo.
|\qquad \textbf{Salida}|: retorna True si existe camino entre v1 y v2, False en caso contrario.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 3}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def isConnected(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación es conexo.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: retorna True si existe camino entre todo par de vértices, False en caso contrario.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 4}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def isTree(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación es árbol.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna True si el grafo es un árbol.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 5}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def isComplete(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación es completo.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna True si el grafo es completo.
\end{lstlisting}
Nota: tener en cuenta que un grafo es completo cuando existe una arista entre todo par de vértices.
\subsubsection*{Solución}


\subsection*{Ejercicio 6}
Implementar una función que dado un grafo devuelva una lista de aristas que si se eliminan el grafo se convierte en un árbol. Respetar la siguiente especificación.
\begin{lstlisting}
|\textbf{def convertTree(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación convertir a árbol.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: LinkedList de las aristas que se pueden eliminar y el grafo resultante se convierte en un árbol.
\end{lstlisting}
\subsubsection*{Solución}


\section*{Parte 2}
\subsection*{Ejercicio 7}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def countConnections(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación cantidad de componentes conexas.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna el número de componentes conexas que componen el grafo.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 8}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def convertToBFSTree(Grafo, v)}|
|\qquad \textbf{Descripción}|: Convierte un grafo en un árbol BFS.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia, v vértice que representa la raíz del árbol.
|\qquad \textbf{Salida}|: Devuelve una Lista de Adyacencia con la representación BFS del grafo recibido usando v como raíz.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 9}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def convertToDFSTree(Grafo, v)}|
|\qquad \textbf{Descripción}|: Convierte un grafo en un árbol DFS.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia, v vértice que representa la raíz del árbol.
|\qquad \textbf{Salida}|: Devuelve una Lista de Adyacencia con la representación DFS del grafo recibido usando v como raíz.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 10}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def bestRoad(Grafo, v1, v2)}|
|\qquad \textbf{Descripción}|: Encuentra el camino más corto, en caso de existir, entre dos vértices.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia, v1 y v2 vértices del grafo.
|\qquad \textbf{Salida}|: Retorna la lista de vértices que representan el camino más corto entre v1 y v2. La lista resultante contiene al inicio a v1 y al final a v2. En caso que no exista camino se retorna la lista vacía.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 11 (Opcional)}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def isBipartite(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa la operación es bipartito.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna True si el grafo es bipartito.
\end{lstlisting}
NOTA: Un grafo es bipartito si no tiene ciclos de longitud impar.
\subsubsection*{Solución}


\subsection*{Ejercicio 12}
Demuestre que si el grafo G es un árbol y se le agrega una arista nueva entre cualquier par de vértices se forma exactamente un ciclo y deja de ser un árbol.
\subsubsection*{Solución}


\subsection*{Ejercicio 13}
Demuestre que si la arista (u,v) no pertenece al árbol BFS, entonces los niveles de u y v difieren a lo sumo en 1.
\subsubsection*{Solución}


\section*{Parte 3}
\subsection*{Ejercicio 14}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def PRIM(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa el algoritmo de PRIM.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna el árbol abarcador de costo mínimo.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 15}
Implementar la función que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def KRUSKAL(Grafo)}|
|\qquad \textbf{Descripción}|: Implementa el algoritmo de KRUSKAL.
|\qquad \textbf{Entrada}|: Grafo con la representación de Lista de Adyacencia.
|\qquad \textbf{Salida}|: Retorna el árbol abarcador de costo mínimo.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 16}
Demostrar que si la arista (u,v) de costo mínimo tiene un nodo en U y otro en V - U, entonces la arista (u,v) pertenece a un árbol abarcador de costo mínimo.
\subsubsection*{Solución}


\section*{Parte 4}
\subsection*{Ejercicio 17}
Sea e la arista de mayor costo de algún ciclo de G(V,A) . Demuestre que existe un árbol abarcador de costo mínimo AACM(V,A-e) que también lo es de G.
\subsubsection*{Solución}


\subsection*{Ejercicio 18}
Demuestre que si unimos dos AACM por un arco (arista) de costo mínimo el resultado es un nuevo AACM. (Base del funcionamiento del algoritmo de Kruskal).
\subsubsection*{Solución}


\subsection*{Ejercicio 19}
Explique qué modificaciones habría que hacer en el algoritmo de Prim sobre el grafo no dirigido y conexo G(V,A), o sobre la función de costo $c(v1,v2) \rightarrow \mathbb{R}$ para lograr:
\begin{enumerate}
    \item Obtener un árbol de recubrimiento de costo máximo.
    \item Obtener un árbol de recubrimiento cualquiera.
    \item Dado un conjunto de aristas $E \in A$, que no forman un ciclo, encontrar el árbol de recubrimiento mínimo $G^c (V,A^c)$ tal que $E \in A^c$.
\end{enumerate}
\subsubsection*{Solución}


\subsection*{Ejercicio 20}
Sea $G = <V, A>$ un grafo conexo, no dirigido y ponderado, donde todas las aristas tienen el mismo costo. Suponiendo que G está implementado usando matriz de adyacencia, haga en pseudocódigo un algoritmo $O(V^2)$ que devuelva una matriz M de VxV donde: M[u, v] = 1 si $(u,v) \in A$ y (u, v) estará obligatoriamente en todo árbol abarcador de costo mínimo de G, y cero en caso contrario.
\subsubsection*{Solución}


\section*{Parte 5}
\subsection*{Ejercicio 21}
Implementar el Algoritmo de Dijkstra que responde a la siguiente especificación.
\begin{lstlisting}
|\textbf{def shortestPath(Grafo, s, v)}|
|\qquad \textbf{Descripción}|: Implementa el algoritmo de Dijkstra.
|\qquad \textbf{Entrada}|: Grafo con la representación de Matriz de Adyacencia, vértice de inicio s y destino v.
|\qquad \textbf{Salida}|: Retorna la lista de los vértices que conforman el camino iniciando por s y terminando en v. Devolver NONE en caso que no exista camino entre s y v.
\end{lstlisting}
\subsubsection*{Solución}


\subsection*{Ejercicio 22 (Opcional)}
Sea $G = <V, A>$ un grafo dirigido y ponderado con la función de costos $C: A \rightarrow R$ de forma tal que $C(v, w) > 0$ para todo arco $<v, w>\ \in A$. Se define el costo $C(p)$ de todo camino $p = <v_0, v_1, \dots, v_k>$ como $C(v_0, v_1) \times C(v_1, v_2) \times \dots \times C(v_k - 1, v_k)$.
\begin{enumerate}
    \item Demuestre que si $p = <v_0, v_1, \dots, v_k>$ es el camino de menor costo con respecto a $C$ en ir de $v_0$ hacia $v_k$, entonces $<v_i, v_i + 1, \dots, vj>$ es el camino de menor costo (también con respecto a $C$) en ir de $v_i$ a $v_j$ para todo $0 \leq i < j \leq k$.
    \item ¿Bajo qué condición o condiciones se puede afirmar que con respecto a $C$ existe camino de costo mínimo entre dos vértices a, $b \in V$? Justifique su respuesta.
    \item Demuestre que, usando la función de costos $C$ tal y como la dan, no se puede aplicar el algoritmo de Dijkstra para hallar los costos de los caminos de costo mínimo desde un vértice de origen s hacia el resto.
    \item Plantee un algoritmo, lo más eficiente en tiempo que usted pueda, que determine los costos de los caminos de costo mínimo desde un vértice de origen $s$ hacia el resto usando la función de costos $C$.
    \item Suponiendo que $C(v, w) > 1$ para todo $<v, w> \in A$, proponga una función de costos $C':A \rightarrow R$ y además la forma de calcular el costo $C'(p)$ de todo camino $p = <v_0, v_1, \dots, v_k>$ de forma tal que: aplicando el algoritmo de Dijkstra usando $C'$, se puedan obtener los costos (con respecto a la función original $C$) de los caminos de costo mínimo desde un vértice de origen $s$ hacia el resto. Justifique su respuesta.
\end{enumerate}
\subsubsection*{Solución}

\end{document}
